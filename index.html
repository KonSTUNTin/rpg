<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Game</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="gameContainer">
        <div id="topSection">
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            <div id="sidebar">                
                <div id="spellsPanel">
                    <h3>–ó–∞–∫–ª–∏–Ω–∞–Ω–∏—è</h3>
                    <div id="spellsList"></div>
                </div>
                
                <div id="terrainActions">
                    <h3>–î–µ–π—Å—Ç–≤–∏—è –Ω–∞ –º–µ—Å—Ç–Ω–æ—Å—Ç–∏</h3>
                    <div id="actionsList"></div>
                </div>
            </div>
        </div>
        
        <div id="gameLog">
            <h3>–õ–æ–≥ –¥–µ–π—Å—Ç–≤–∏–π</h3>
            <div id="logContent"></div>
        </div>
    </div>
    
    <div id="battleOverlay"></div>
    <div id="battle">
        <div id="battleContent"></div>
    </div>

    <script>
// –ú–∞—Å—Å–∏–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π –æ–±—ä–µ–∫—Ç–æ–≤
const OBJECT_CONFIGS = [
    {
        type: 'monster',
        color: 'purple',
        resourceGain: { '‚ô†': 2, '‚ô£': 1 }
    },
    {
        type: 'chest',
        color: 'gold',
        resourceGain: { '‚ô¶': 3 }
    }
];

// –ú–∞—Å—Å–∏–≤ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–π
const SPELLS = [
    {
        name: '–û–≥–Ω–µ–Ω–Ω—ã–π —à–∞—Ä',
        cost: { '‚ô†': 2, '‚ô¶': 1 },
        damage: { '‚ô•': 2, '‚ô¶': 1, '‚ô†': 1,'‚ô£': 2 },
        combat: true
    },
    {
        name: '–õ—ë–¥',
        cost: { '‚ô£': 1 },
        damage: { '‚ô•': 2, '‚ô¶': 1, '‚ô†': 1,'‚ô£': 2 },
        combat: true
    },
    {
        name: '–ò—Å—Ü–µ–ª–µ–Ω–∏–µ',
        cost: { '‚ô£': 2 },
        effect: () => {
            game.addLogEntry('–í—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –∏—Å—Ü–µ–ª–µ–Ω–∏–µ! üíö', 'player');
        },
        combat: false
    },
    {
        name: '–ü—Ä–∏–∑—ã–≤ —Å—É–Ω–¥—É–∫–∞',
        cost: { '‚ô†': 1, '‚ô£': 1 },
        effect: function () {
            const x = Math.floor(Math.random() * CONFIG.COLS);
            const y = Math.floor(Math.random() * CONFIG.ROWS);
            if (game.terrain[y][x] !== 1) {
                game.objects.push(new Chest(x, y));
                game.addLogEntry(`–ü—Ä–∏–∑–≤–∞–Ω —Å—É–Ω–¥—É–∫ –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ (${x}, ${y})`, 'player');
            } else {
                game.addLogEntry('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–∑–≤–∞—Ç—å —Å—É–Ω–¥—É–∫ - –º–µ—Å—Ç–æ –∑–∞–Ω—è—Ç–æ', 'error');
            }
        },
        combat: false
    }
];

// –ú–∞—Å—Å–∏–≤ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–µ–π
const SURFACES = [
    {
        id: 0,
        name: '–ü–æ–ª–µ',
        color: '#90EE90',
        probability: 0.5,
        moveCost: { '‚ô†': 0 },
        actions: [
            { label: '–°–æ–±—Ä–∞—Ç—å —É—Ä–æ–∂–∞–π', cost: {}, gain: { '‚ô†': 1 }, combat: false, depth: 1 },
            { label: '–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –∞–º–±–∞—Ä', cost: { '‚ô†': 2 }, gain: { '‚ô¶': 1 }, combat: false, depth: 1 }
        ]
    },
    {
        id: 1,
        name: '–°–∫–∞–ª—ã',
        color: '#A9A9A9',
        probability: 0.1,
        moveCost: { '‚ô†': 0 },
        actions: []
    },
    {
        id: 2,
        name: '–†–µ–∫–∞',
        color: '#87CEEB',
        probability: 0.4,
        moveCost: { '‚ô£': 0 },
        actions: [
            { label: '–ü–æ—Ä—ã–±–∞—á–∏—Ç—å', cost: {}, gain: { '‚ô£': 1 }, combat: false, depth: 2 },
            { label: '–ù–∞–±—Ä–∞—Ç—å –≤–æ–¥—É', cost: { '‚ô£': 1 }, gain: { '‚ô¶': 2 }, combat: false, depth: 2 }
        ]
    },
    {
        id: 3,
        name: '–õ–µ—Å',
        color: '#006400',
        probability: 0.4,
        moveCost: { '‚ô£': 0 },
        actions: [
            { label: '–†—É–±–∏—Ç—å –ª–µ—Å', cost: {}, gain: { '‚ô£': 1 }, combat: false, depth: 3 }
        ]
    }
];

// –û—Å–Ω–æ–≤–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
const CONFIG = {
    TILE_SIZE: 50,
    ROWS: 8,
    COLS: 12,
    MONSTER_COUNT: 5,
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –æ–±—ä–µ–∫—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
    OBJECT_CONFIG: OBJECT_CONFIGS.reduce((acc, config) => {
        acc[config.type] = config;
        return acc;
    }, {}),
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Å—Å–∏–≤—ã –∏–∑ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π
    SPELLS: SPELLS,
    SURFACES: SURFACES
};

class GameObject {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.config = CONFIG.OBJECT_CONFIG[type];
    }

    interact(player) {
        if (this.config.resourceGain) {
            player.gain(this.config.resourceGain);
        }
    }

    draw(ctx) {
        const cx = this.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const cy = this.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        ctx.beginPath();
        ctx.arc(cx, cy, CONFIG.TILE_SIZE / 4, 0, 2 * Math.PI);
        ctx.fillStyle = this.config.color;
        ctx.fill();
        ctx.stroke();
    }
}

class Chest extends GameObject {
    constructor(x, y) {
        super(x, y, 'chest');
    }
}

class Monster extends GameObject {
    constructor(x, y) {
        super(x, y, 'monster');
        this.hp = { '‚ô†': 2, '‚ô£': 2, '‚ô¶': 1 };
        this.maxHp = { '‚ô†': 2, '‚ô£': 2, '‚ô¶': 1 };
    }

    receiveDamage(damage) {
        let totalDamage = 0;
        for (let res in damage) {
            const taken = Math.min(this.hp[res] || 0, damage[res]);
            this.hp[res] = Math.max(0, (this.hp[res] || 0) - taken);
            game.player.gain({ [res]: taken });
            totalDamage += taken;
        }
        
        if (totalDamage > 0) {
            game.addLogEntry(`–ú–æ–Ω—Å—Ç—Ä –ø–æ–ª—É—á–∏–ª —É—Ä–æ–Ω: ${formatResources(damage)}`, 'monster');
            game.addLogEntry(`–í—ã –ø–æ–ª—É—á–∏–ª–∏ —Ä–µ—Å—É—Ä—Å—ã: ${formatResources(damage)}`, 'player');
        }
        
        // –ú–æ–Ω—Å—Ç—Ä –∞—Ç–∞–∫—É–µ—Ç –≤ –æ—Ç–≤–µ—Ç, –µ—Å–ª–∏ –∂–∏–≤
        if (!this.isDead()) {
            this.attack();
        }
    }
    
    attack() {
        const damage = { '‚ô†': 1, '‚ô£': 1 };
        let canTakeDamage = false;
        
        for (let res in damage) {
            if ((game.player.resources[res] || 0) >= damage[res]) {
                canTakeDamage = true;
                break;
            }
        }
        
        if (canTakeDamage) {
            for (let res in damage) {
                const taken = Math.min(game.player.resources[res] || 0, damage[res]);
                game.player.resources[res] = Math.max(0, (game.player.resources[res] || 0) - taken);
            }
            game.addLogEntry(`–ú–æ–Ω—Å—Ç—Ä –∞—Ç–∞–∫–æ–≤–∞–ª –≤–∞—Å! –ü–æ—Ç–µ—Ä—è–Ω—ã —Ä–µ—Å—É—Ä—Å—ã: ${formatResources(damage)}`, 'monster');
        } else {
            game.addLogEntry('–ú–æ–Ω—Å—Ç—Ä –∞—Ç–∞–∫–æ–≤–∞–ª, –Ω–æ —É –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è —É—Ä–æ–Ω–∞', 'monster');
        }
    }

    isDead() {
        return Object.values(this.hp).every(val => val === 0);
    }

    getHpString() {
        return Object.entries(this.hp).map(([k, v]) => `${k}${v}`).join(' ');
    }
}

class Player {
    constructor(x = 0, y = 0, resources = { '‚ô†': 3, '‚ô¶': 5, '‚ô£': 2 }) {
        this.x = x;
        this.y = y;
        this.resources = resources;
    }

    canAfford(cost) {
        return Object.entries(cost).every(([k, v]) => (this.resources[k] || 0) >= v);
    }

    applyCost(cost) {
        for (let res in cost) this.resources[res] -= cost[res];
    }

    gain(gain) {
        for (let res in gain) this.resources[res] = (this.resources[res] || 0) + gain[res];
    }
}

class TerrainManager {
    constructor(rows, cols, surfaces) {
        this.rows = rows;
        this.cols = cols;
        this.surfaces = surfaces;
        this.seedX = Math.random() * 1000;
        this.seedY = Math.random() * 1000;
        this.map = this.generate();
        this.depthMap = this.generateDepthMap();
    }

    noise(x, y) {
        return Math.sin((x + this.seedX) * 3.14 + (y + this.seedY) * 1.618) * Math.cos((y + this.seedY) * 3.14 + (x + this.seedX) * 1.618);
    }

    generate(scale = Math.random() * 0.3 + 0.1) {
        const map = [];
        for (let y = 0; y < this.rows; y++) {
            const row = [];
            for (let x = 0; x < this.cols; x++) {
                const v = (this.noise(x * scale, y * scale) + 1) / 2;
                let idx = Math.floor(v * this.surfaces.length);
                idx = Math.min(idx, this.surfaces.length - 1);
                let tile = this.surfaces[idx];
                if (Math.random() > tile.probability) {
                    tile = this.surfaces.find(s => Math.random() <= s.probability) || tile;
                }
                row.push(tile.id);
            }
            map.push(row);
        }
        return map;
    }

    generateDepthMap() {
        const map = [];
        for (let y = 0; y < this.rows; y++) {
            const row = [];
            for (let x = 0; x < this.cols; x++) {
                const surface = this.getSurface(this.map[y][x]);
                const maxDepth = surface.actions?.reduce((max, act) => Math.max(max, act.depth || 1), 1);
                row.push(maxDepth);
            }
            map.push(row);
        }
        return map;
    }

    reduceDepth(x, y) {
        if (this.depthMap[y][x] > 0) this.depthMap[y][x]--;
    }

    getSurface(id) {
        return this.surfaces.find(s => s.id === id);
    }
}

function formatResources(obj) {
    return Object.entries(obj).map(([k, v]) => `${k}${v}`).join(' ');
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.player = new Player();
        this.terrainManager = new TerrainManager(CONFIG.ROWS, CONFIG.COLS, CONFIG.SURFACES);
        this.terrain = this.terrainManager.map;
        this.objects = [];
        this.paused = false;
        this.currentMonster = null;
        this.currentMonsterIndex = -1;
        this.actionMappings = {}; // –î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π —Ü–∏—Ñ—Ä –∏ –¥–µ–π—Å—Ç–≤–∏–π
        this.logEntries = [];
        this.generateObjects();
        this.bindKeys();
        this.updateUI();
        this.addLogEntry('–ò–≥—Ä–∞ –Ω–∞—á–∞—Ç–∞! –ò—Å—Å–ª–µ–¥—É–π—Ç–µ –º–∏—Ä –∏ —Å—Ä–∞–∂–∞–π—Ç–µ—Å—å —Å –º–æ–Ω—Å—Ç—Ä–∞–º–∏.', 'system');
        requestAnimationFrame(() => this.update());
    }
    
    addLogEntry(message, type = 'system') {
        const timestamp = new Date().toLocaleTimeString();
        this.logEntries.push({
            time: timestamp,
            message: message,
            type: type
        });
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –≤ –ª–æ–≥–µ
        if (this.logEntries.length > 50) {
            this.logEntries.shift();
        }
        
        this.updateLogDisplay();
    }
    
    updateLogDisplay() {
        const logContent = document.getElementById('logContent');
        logContent.innerHTML = '';
        
        this.logEntries.forEach(entry => {
            const div = document.createElement('div');
            div.className = `log-entry log-${entry.type}`;
            div.textContent = `[${entry.time}] ${entry.message}`;
            logContent.appendChild(div);
        });
        
        // –ê–≤—Ç–æ—Å–∫—Ä–æ–ª–ª –≤–Ω–∏–∑
        logContent.scrollTop = logContent.scrollHeight;
    }

    generateObjects() {
        while (this.objects.filter(o => o instanceof Monster).length < CONFIG.MONSTER_COUNT) {
            const x = Math.floor(Math.random() * CONFIG.COLS);
            const y = Math.floor(Math.random() * CONFIG.ROWS);
            if (this.terrain[y][x] !== 1 && (x !== this.player.x || y !== this.player.y)) {
                this.objects.push(new Monster(x, y));
            }
        }
    }

    bindKeys() {
        document.addEventListener('keydown', (e) => {
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –µ—Å–ª–∏ –∏–≥—Ä–∞ –Ω–∞ –ø–∞—É–∑–µ
            if (this.paused) {
                // –í –±–æ—é –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã
                if (e.key >= '1' && e.key <= '9') {
                    this.handleNumberKey(parseInt(e.key));
                }
                return;
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ü–∏—Ñ—Ä –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π
            if (e.key >= '1' && e.key <= '9') {
                this.handleNumberKey(parseInt(e.key));
                return;
            }
            
            const dir = {
                ArrowUp: [0, -1],
                ArrowDown: [0, 1],
                ArrowLeft: [-1, 0],
                ArrowRight: [1, 0]
            }[e.key];
            
            if (dir) {
                e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å–∫—Ä–æ–ª–ª —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                const [dx, dy] = dir;
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã
                if (newX >= 0 && newX < CONFIG.COLS && newY >= 0 && newY < CONFIG.ROWS) {
                    const surface = this.terrainManager.getSurface(this.terrain[newY][newX]);
                    if (surface && this.player.canAfford(surface.moveCost)) {
                        this.player.applyCost(surface.moveCost);
                        this.player.x = newX;
                        this.player.y = newY;
                        this.addLogEntry(`–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –Ω–∞ ${surface.name} (${newX}, ${newY})`, 'player');
                        this.interactWithObjects();
                        this.updateUI();
                        this.updateGameStatus(`Moved to ${surface.name}`);
                    } else {
                        this.addLogEntry('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–≤–∏–≥–∞—Ç—å—Å—è - –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ä–µ—Å—É—Ä—Å–æ–≤', 'error');
                        this.updateGameStatus('Cannot move - insufficient resources');
                    }
                } else {
                    this.addLogEntry('–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–≤–∏–≥–∞—Ç—å—Å—è - –≥—Ä–∞–Ω–∏—Ü–∞ –∫–∞—Ä—Ç—ã', 'error');
                    this.updateGameStatus('Cannot move - boundary reached');
                }
            }
        });
    }
    
    handleNumberKey(number) {
        if (this.actionMappings[number]) {
            const action = this.actionMappings[number];
            action.callback();
        }
    }

    interactWithObjects() {
        const objIndex = this.objects.findIndex(o => o.x === this.player.x && o.y === this.player.y);
        if (objIndex !== -1) {
            const obj = this.objects[objIndex];
            if (obj instanceof Monster) {
                this.addLogEntry(`–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –º–æ–Ω—Å—Ç—Ä–æ–º! –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è –±–æ–π.`, 'monster');
                this.startBattle(obj, objIndex);
            } else {
                obj.interact(this.player);
                this.addLogEntry(`–ù–∞–π–¥–µ–Ω —Å—É–Ω–¥—É–∫! –ü–æ–ª—É—á–µ–Ω—ã —Ä–µ—Å—É—Ä—Å—ã: ${formatResources(obj.config.resourceGain)}`, 'player');
                this.objects.splice(objIndex, 1);
            }
        }
    }

    startBattle(monster, index) {
        this.paused = true;
        this.currentMonster = monster;
        this.currentMonsterIndex = index;

        const battleOverlay = document.getElementById('battleOverlay');
        const battlePanel = document.getElementById('battle');
        const battleContent = document.getElementById('battleContent');

        battleOverlay.style.display = 'block';
        battlePanel.style.display = 'block';

        this.updateBattleUI();
    }

    updateBattleUI() {
        const battleContent = document.getElementById('battleContent');
        battleContent.innerHTML = '';
        this.actionMappings = {}; // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –º–∞–ø–ø–∏–Ω–≥–∏

        // Monster info
        const monsterInfo = document.createElement('div');
        monsterInfo.className = 'monster-info';
        monsterInfo.innerHTML = `
            <h3>üêâ –ë–∏—Ç–≤–∞ —Å –º–æ–Ω—Å—Ç—Ä–æ–º</h3>
            <p><strong>HP –º–æ–Ω—Å—Ç—Ä–∞:</strong> ${this.currentMonster.getHpString()}</p>
        `;
        battleContent.appendChild(monsterInfo);

        // Combat spells
        const combatSpells = CONFIG.SPELLS.filter(s => s.combat);
        combatSpells.forEach((spell, index) => {
            const spellDiv = document.createElement('div');
            spellDiv.className = 'spell-info';
            
            const canAfford = this.player.canAfford(spell.cost);
            const btn = document.createElement('button');
            btn.className = 'battle-button';
            btn.innerHTML = `<span class="hotkey">${index + 1}</span>${spell.name} (${formatResources(spell.cost)}) - —É—Ä–æ–Ω: ${formatResources(spell.damage)}`;
            btn.disabled = !canAfford;
            
            const spellAction = () => {
                if (!this.player.canAfford(spell.cost)) {
                    return;
                }
                this.player.applyCost(spell.cost);
                this.addLogEntry(`–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ: ${spell.name}`, 'player');
                this.currentMonster.receiveDamage(spell.damage);
                
                if (this.currentMonster.isDead()) {
                    this.objects.splice(this.currentMonsterIndex, 1);
                    this.addLogEntry('–ú–æ–Ω—Å—Ç—Ä –ø–æ–±–µ–∂–¥–µ–Ω!', 'system');
                    this.updateGameStatus('Monster defeated!');
                    this.endBattle();
                    this.generateObjects(); // Spawn new monsters
                } else {
                    this.updateBattleUI();
                }
                this.updateUI();
            };
            
            btn.onclick = spellAction;
            this.actionMappings[index + 1] = { callback: spellAction };
            
            spellDiv.appendChild(btn);
            battleContent.appendChild(spellDiv);
        });

        // Flee button
        const fleeBtn = document.createElement('button');
        fleeBtn.className = 'battle-button flee-button';
        fleeBtn.innerHTML = `<span class="hotkey">${combatSpells.length + 1}</span>üèÉ –°–±–µ–∂–∞—Ç—å`;
        const fleeAction = () => {
            this.addLogEntry('–í—ã —Å–±–µ–∂–∞–ª–∏ –∏–∑ –±–æ—è!', 'player');
            this.endBattle();
        };
        fleeBtn.onclick = fleeAction;
        this.actionMappings[combatSpells.length + 1] = { callback: fleeAction };
        battleContent.appendChild(fleeBtn);
    }

    endBattle() {
        this.currentMonster = null;
        this.currentMonsterIndex = -1;
        this.paused = false;
        this.actionMappings = {}; // –û—á–∏—â–∞–µ–º –±–æ–µ–≤—ã–µ –º–∞–ø–ø–∏–Ω–≥–∏
        this.updateGameStatus('Ready to explore');
        
        const battleOverlay = document.getElementById('battleOverlay');
        const battlePanel = document.getElementById('battle');
        
        battleOverlay.style.display = 'none';
        battlePanel.style.display = 'none';
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—ã—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è
        this.updateUI();
        
        // –£–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ –∏–≥—Ä–∞ –Ω–µ –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞
        setTimeout(() => {
            if (this.paused) {
                this.paused = false;
            }
        }, 100);
    }

    updateGameStatus(message) {
        const statusElement = document.getElementById('gameStatus');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.style.color = this.paused ? 'red' : 'green';
        }
    }

    updateUI() {
        this.actionMappings = {}; // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –º–∞–ø–ø–∏–Ω–≥–∏
        let actionIndex = 1;
        
        // Update spells panel
        const spellsList = document.getElementById('spellsList');
        spellsList.innerHTML = '';
        
        const nonCombatSpells = CONFIG.SPELLS.filter(s => !s.combat);
        nonCombatSpells.forEach(spell => {
            const spellDiv = document.createElement('div');
            spellDiv.className = 'spell-info';
            
            const canAfford = this.player.canAfford(spell.cost);
            const btn = document.createElement('button');
            btn.className = 'battle-button';
            btn.innerHTML = `<span class="hotkey">${actionIndex}</span>${spell.name} (${formatResources(spell.cost)})`;
            btn.disabled = !canAfford;
            
            const spellAction = () => {
                if (this.player.canAfford(spell.cost)) {
                    this.player.applyCost(spell.cost);
                    this.addLogEntry(`–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ: ${spell.name}`, 'player');
                    if (spell.effect) {
                        spell.effect();
                    }
                    this.updateUI();
                }
            };
            
            btn.onclick = spellAction;
            this.actionMappings[actionIndex] = { callback: spellAction };
            actionIndex++;
            
            spellDiv.appendChild(btn);
            spellsList.appendChild(spellDiv);
        });

        // Update terrain actions
        const actionsList = document.getElementById('actionsList');
        actionsList.innerHTML = '';
        
        const currentSurface = this.terrainManager.getSurface(this.terrain[this.player.y][this.player.x]);
        if (currentSurface && currentSurface.actions) {
            currentSurface.actions.forEach(action => {
                const actionDiv = document.createElement('div');
                actionDiv.className = 'spell-info';
                
                const canAfford = this.player.canAfford(action.cost);
                const btn = document.createElement('button');
                btn.className = 'battle-button';
                btn.innerHTML = `<span class="hotkey">${actionIndex}</span>${action.label} (${formatResources(action.cost)}) ‚Üí ${formatResources(action.gain)}`;
                btn.disabled = !canAfford;
                
                const terrainAction = () => {
                    if (this.player.canAfford(action.cost)) {
                        this.player.applyCost(action.cost);
                        this.player.gain(action.gain);
                        this.addLogEntry(`–í—ã–ø–æ–ª–Ω–µ–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ: ${action.label}. –ü–æ–ª—É—á–µ–Ω–æ: ${formatResources(action.gain)}`, 'player');
                        this.updateUI();
                        this.updateGameStatus(`Performed ${action.label}`);
                    }
                };
                
                btn.onclick = terrainAction;
                this.actionMappings[actionIndex] = { callback: terrainAction };
                actionIndex++;
                
                actionDiv.appendChild(btn);
                actionsList.appendChild(actionDiv);
            });
        }
    }

    update() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawGrid();
        this.drawObjects();
        this.drawPlayer();
        this.drawResources();
        requestAnimationFrame(() => this.update());
    }

    drawGrid() {
        for (let y = 0; y < CONFIG.ROWS; y++) {
            for (let x = 0; x < CONFIG.COLS; x++) {
                const tileId = this.terrain[y][x];
                const surface = this.terrainManager.getSurface(tileId);
                this.ctx.fillStyle = surface.color;
                this.ctx.fillRect(x * CONFIG.TILE_SIZE, y * CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                this.ctx.strokeStyle = '#333';
                this.ctx.strokeRect(x * CONFIG.TILE_SIZE, y * CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            }
        }
    }

    drawPlayer() {
        const cx = this.player.x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        const cy = this.player.y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
        this.ctx.beginPath();
        this.ctx.arc(cx, cy, CONFIG.TILE_SIZE / 4, 0, 2 * Math.PI);
        this.ctx.fillStyle = 'red';
        this.ctx.fill();
        this.ctx.strokeStyle = '#000';
        this.ctx.stroke();
    }

    drawObjects() {
        for (const obj of this.objects) {
            obj.draw(this.ctx);
        }
    }

    drawResources() {
        this.ctx.fillStyle = '#000';
        this.ctx.font = '18px Arial';
        this.ctx.textAlign = 'left';
        let offset = 10;
        for (let key in this.player.resources) {
            this.ctx.fillText(`${key} ${this.player.resources[key]}`, offset, 25);
            offset += 60;
        }
    }
}

let game = new Game();
</script>
</body>
</html>